[[cha:qtscreen]]

= QTscreen

== Intro

QTscreen is an infrastructure to display a custom screen or VCP panel in LinuxCNC. +
It displays a UI file built with the QTDesigner screen editor or combines this +
with python programming to create a GUI screen for running a CNC machine. +
QTscreen is customizable - you can add different buttons and status LEDs etc. +

.QT_cnc - 3 Axis Sample
image::images/qt_cnc.png["QTscreen Mill",align="left"]

=== INI Settings

If you are using this to make a CNC control screen: +
Under the [DISPLAY] heading:

----
DISPLAY = qtscreen <screen_name>
  options:
    -d debugging on
    -a set window always on top
    -c HAL component name. Default is to use the UI file name.
    -g geometry: WIDTHxHEIGHT+XOFFSET+YOFFSET
    -m maximise window
    -f fullscreen the window
    -t theme. Default is system theme
    <screen_name> is the base name of the .ui and _handler.py files.
    If <screen_name> is missing the default screen will be loaded.
----
QTscreen assumes the UI file and the handler file use this same base name. +
QTscreen will search the LinuxCNC configuration file that was launched first for the files,  +
then in the system skin folder. the skin folders holds standard screens. +

== Overview

There are two files that can be used, individually or in combination to add +
customization. Normally QTscreen uses the stock UI and handler file. +
You can specify QTscreen to use 'local' UI and handler files. +
One is not restricted to adding a custom panel on the right or a custom tab. +
QTscreen leverages 'QT Designer' (the editor) and 'PyQT4' (the widget toolkit). +
QTvcp has some special widgets and actions added just for LinuxCNC. +

=== QTDesigner UI File

A designer file is a text file organized in the XML standard that describes the +
layout and the widgets of the screen. Pyqt4 uses this file to build the display +
and react to those widgets. The QTDesigner editor makes it relatively easy to build +
and edit this file. +

=== Handler Files

A handler file is a file containing python code, which QTscreen adds to it's +
default routines. A handler file allows one to modify defaults, or add logic +
to a QTscreen skin without having to modify QTscreen proper.  +
If present a handler file will be loaded. +
Only one file is allowed. QTscreen looks for the handler file. +
In this way you can have custom behaviour. +
Here is a sample handler file. +
It's broken up in sections for ease of discussion. +

[source,python]
----
############################
# **** IMPORT SECTION **** #
############################

from PyQt4 import QtGui
from qtvcp.lib.keybindings import Keylookup
from qtvcp.core import Status
import linuxcnc
import sys
import os

###########################################
# **** instantiate libraries section **** #
###########################################

KEYBIND = Keylookup()
STATUS = Status()

###################################
# **** HANDLER CLASS SECTION **** #
###################################

class HandlerClass:

    ########################
    # **** INITIALIZE **** #
    ########################
    # widgets allows access to  widgets from the qtvcp files
    # at this point the widgets and hal pins are not instantiated
    def __init__(self, halcomp,widgets,paths):
        self.hal = halcomp
        self.w = widgets
        self.stat = linuxcnc.stat()
        self.cmnd = linuxcnc.command()
        self.jog_velocity = 10.0

        # connect to GStat to catch linuxcnc events
        STATUS.connect('state-on', self.on_state_on)
        STATUS.connect('state-off', self.on_state_off)

    #######################################
    # **** Special Functions SECTION **** #
    #######################################

    # at this point:
    # the widgets are instantiated.
    # the HAL pins are built but HAL is not set ready
    # you could still make arbritrary HAL pins here
    def initialized__(self):
        STATUS.forced_update()

    def processed_key_event__(self,receiver,event,is_pressed,key,code,shift,cntrl):
        # when typing in MDI, we don't want keybinding to call functions
        # so we catch and process the events directly.
        # We do want ESC, F1 and F2 to call keybinding functions though
        if self.w.mdi_line == receiver and code not in(16777216,16777264,16777216):
            if is_pressed:
                self.w.mdi_line.keyPressEvent(event)
                event.accept()
            return True
        try:
            KEYBIND.call(self,event,is_pressed,shift,cntrl)
            return True
        except AttributeError:
            print 'no function %s in handler file for-%s'%(KEYBIND.convert(event),key)
            #print 'from %s'% receiver
            return False

    #####################################
    # **** STATUS CALLBACKS SECTION **** #
    #####################################

    def on_state_on(self,w):
        print 'machine on'

    def on_state_off(self,w):
        print 'machine off'

    #####################################
    # **** QTFORM CALLBACK SECTION **** #
    #####################################

    def zero_axis(self):
        name = self.w.sender().text()
        print name
        if 'X' in name:
            STATUS.set_axis_origin('x',0)
        elif 'Y' in name:
            STATUS.set_axis_origin('y',0)
        elif 'Z' in name:
            STATUS.set_axis_origin('z',0)

    #######################################
    # **** GENERAL FUNCTIONS SECTION **** #
    #######################################

    def continous_jog(self, axis, direction):
        STATUS.continuous_jog(axis, direction)

    #################################
    # **** KEY BINDING SECTION **** #
    #################################
    def on_keycall_ESTOP(self,event,state,shift,cntrl):
        if state:
            self.w.button_estop.click()
    def on_keycall_POWER(self,event,state,shift,cntrl):
        if state:
            self.w.button_machineon.click()
    def on_keycall_HOME(self,event,state,shift,cntrl):
        if state:
            self.w.button_home.click()

    ###########################
    # **** CLOSING EVENT **** #
    ###########################
    def closeEvent(self, event):
        event.accept()

    ##############################
    # required class boiler code #
    ##############################

    def __getitem__(self, item):
        return getattr(self, item)
    def __setitem__(self, item, value):
        return setattr(self, item, value)

################################
# required handler boiler code #
################################

def get_handlers(halcomp,widgets,paths):
     return [HandlerClass(halcomp,widgets,paths)]
----
=== Libraries

Qtscreen as built does little more then display the screen and react to widgets. +
For more prebuilt behaviours there are available libraries. +
(found in lib/python/qtvcp/lib in RIP linuxcnc install) +

aux_program_loader +
keybindings +
message +
preferences +
notify +

=== Themes

Themes are a way to modify the look and feel of the widgets on the screen. +
For instance the color or size of buttons and sliders can be changed using
themes. +
The Windows theme is default for screens. System theme is default for panels. +
to see available themes load qtscreen with -d -t SHOWTHEMES +

Qtscreen can also be customized with Qt stylesheets using css. +


=== Build a Qtscreen Panel

To build a panel or screen use QTDesigner to build a design you like. +
Save this UI file to your configuration folder with a name of your choice, ending with .ui +

==== Local Files

If present, local UI files in the configuration folder will be loaded instead +
of the stock UI files. Local UI files allow you to use your customized +
designs rather then the default screens. +
QTscreen will look for MYNAME.ui and MYNAME_handler.py in the launched configuration folder. +


==== Modifying Stock Screens
If you wish to modify a stock screen, copy it's UI and handler file to your configuration folder. +

== Libraries modules
Qtscreen as built does little more then display the screen and react to widgets. +
For more prebuilt behaviours there are available libraries. +
(found in lib/python/qtvcp/lib in RIP linuxcnc install) +
libraries are prebuilt python modules that give added features to QTvcp. +
In this way you can select what features you want - yet don't have to build common ones yourself. +
Such libraries include keybindings, preference recording, desktop notification etc. +

== QTvcp Widgets

Qtscreen uses QTvcp widgets for linuxcnc integration.
Widget is the general name for the UI objects such as buttons and labels in QTpy4. +
You are free to use any available widgets in the QTDesigner editor. +
There are also special widgets made for linuxcnc that make integration easier. +
This are split in three heading on the left side of the editor. +
One is for HAL only widgets. +
One is for cnc control widgets. +
One is for dialog widgets. +
you are free to mix them in any way on your panel. +


